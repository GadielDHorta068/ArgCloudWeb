{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let VirtualMachineService = /*#__PURE__*/(() => {\n  class VirtualMachineService {\n    constructor(http) {\n      this.http = http;\n      this.apiUrl = 'http://localhost:8080/api/vms';\n    }\n    /**\n     * Obtiene los headers con el token de autenticación\n     */\n    getAuthHeaders() {\n      const token = localStorage.getItem('token');\n      return new HttpHeaders({\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      });\n    }\n    /**\n     * Maneja errores de las peticiones HTTP\n     */\n    handleError(error) {\n      console.error('Error en VirtualMachineService:', error);\n      let errorMessage = 'Ha ocurrido un error inesperado';\n      if (error.error?.message) {\n        errorMessage = error.error.message;\n      } else if (error.message) {\n        errorMessage = error.message;\n      }\n      return throwError(() => new Error(errorMessage));\n    }\n    /**\n     * Crea una nueva máquina virtual\n     */\n    createVirtualMachine(request) {\n      return this.http.post(this.apiUrl, request, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Obtiene todas las máquinas virtuales del usuario\n     */\n    getUserVirtualMachines() {\n      return this.http.get(this.apiUrl, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(responses => responses.map(response => this.mapResponseToVirtualMachine(response))), catchError(this.handleError));\n    }\n    /**\n     * Obtiene una máquina virtual específica\n     */\n    getVirtualMachine(id) {\n      return this.http.get(`${this.apiUrl}/${id}`, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Inicia una máquina virtual\n     */\n    startVirtualMachine(id) {\n      return this.http.post(`${this.apiUrl}/${id}/start`, {}, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Detiene una máquina virtual\n     */\n    stopVirtualMachine(id) {\n      return this.http.post(`${this.apiUrl}/${id}/stop`, {}, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Reinicia una máquina virtual\n     */\n    restartVirtualMachine(id) {\n      return this.http.post(`${this.apiUrl}/${id}/restart`, {}, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Elimina una máquina virtual\n     */\n    deleteVirtualMachine(id) {\n      return this.http.delete(`${this.apiUrl}/${id}`, {\n        headers: this.getAuthHeaders()\n      }).pipe(catchError(this.handleError));\n    }\n    /**\n     * Sincroniza el estado de una máquina virtual\n     */\n    syncVirtualMachine(id) {\n      return this.http.post(`${this.apiUrl}/${id}/sync`, {}, {\n        headers: this.getAuthHeaders()\n      }).pipe(map(response => this.mapResponseToVirtualMachine(response)), catchError(this.handleError));\n    }\n    /**\n     * Obtiene los nodos disponibles\n     */\n    getAvailableNodes() {\n      return this.http.get(`${this.apiUrl}/nodes`, {\n        headers: this.getAuthHeaders()\n      }).pipe(catchError(this.handleError));\n    }\n    /**\n     * Mapea la respuesta del servidor al modelo de VirtualMachine\n     */\n    mapResponseToVirtualMachine(response) {\n      return {\n        id: response.id,\n        name: response.name,\n        status: response.status,\n        os: response.os,\n        cpu: response.cpu,\n        memory: response.memory,\n        disk: response.disk,\n        ipAddress: response.ipAddress,\n        macAddress: response.macAddress,\n        nodeName: response.nodeName,\n        createdAt: response.createdAt,\n        updatedAt: response.updatedAt,\n        userName: response.userName\n      };\n    }\n    /**\n     * Obtiene el icono CSS para el estado de la VM\n     */\n    getStatusIcon(status) {\n      switch (status) {\n        case 'running':\n          return 'fas fa-play-circle text-success';\n        case 'stopped':\n          return 'fas fa-stop-circle text-danger';\n        case 'restarting':\n          return 'fas fa-sync-alt fa-spin text-warning';\n        case 'creating':\n          return 'fas fa-cog fa-spin text-info';\n        case 'deleting':\n          return 'fas fa-trash-alt text-danger';\n        case 'error':\n          return 'fas fa-exclamation-triangle text-danger';\n        default:\n          return 'fas fa-question-circle text-muted';\n      }\n    }\n    /**\n     * Obtiene el texto legible para el estado de la VM\n     */\n    getStatusText(status) {\n      switch (status) {\n        case 'running':\n          return 'En ejecución';\n        case 'stopped':\n          return 'Detenida';\n        case 'restarting':\n          return 'Reiniciando';\n        case 'creating':\n          return 'Creando';\n        case 'deleting':\n          return 'Eliminando';\n        case 'error':\n          return 'Error';\n        default:\n          return 'Desconocido';\n      }\n    }\n    /**\n     * Obtiene la clase CSS para el estado de la VM\n     */\n    getStatusClass(status) {\n      switch (status) {\n        case 'running':\n          return 'badge badge-success';\n        case 'stopped':\n          return 'badge badge-secondary';\n        case 'restarting':\n          return 'badge badge-warning';\n        case 'creating':\n          return 'badge badge-info';\n        case 'deleting':\n          return 'badge badge-danger';\n        case 'error':\n          return 'badge badge-danger';\n        default:\n          return 'badge badge-light';\n      }\n    }\n    static {\n      this.ɵfac = function VirtualMachineService_Factory(t) {\n        return new (t || VirtualMachineService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: VirtualMachineService,\n        factory: VirtualMachineService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return VirtualMachineService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}